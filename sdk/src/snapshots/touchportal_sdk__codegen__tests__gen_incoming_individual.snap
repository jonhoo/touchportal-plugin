---
source: sdk/src/codegen.rs
expression: incoming_code
---
# [diagnostic :: on_unimplemented (message = "`{Self}` must implement `PluginCallbacks` to receive updates from TouchPortal " , label = "the trait `PluginCallbacks` is not implemented for `{Self}`" , note = "Add `impl PluginCallbacks for {Self} {{}}` and let your IDE or the compiler guide you." , note = "This trait has methods for all possible \"incoming\" messages based on your plugin description in `build.rs`." ,)] trait PluginCallbacks { async fn on_test_action (& mut self , mode : protocol :: ActionInteractionMode , text_data : String , choice_data : ChoicesForChoiceData) -> eyre :: Result < () > ; async fn on_select_choice_data_in_test_action (& mut self , instance : String , selected : ChoicesForChoiceData ,) -> eyre :: Result < () > ; async fn on_broadcast (& mut self , event : protocol :: BroadcastEvent) -> eyre :: Result < () > { tracing :: debug ! (? event , "on_broadcast noop") ; Ok (()) } async fn on_close (& mut self , eof : bool) -> eyre :: Result < () > { tracing :: debug ! (? eof , "on_close noop") ; Ok (()) } async fn on_notification_clicked (& mut self , event : protocol :: NotificationClickedMessage) -> eyre :: Result < () > { tracing :: debug ! (? event , "on_notification_clicked noop") ; Ok (()) } # [doc = r" Called when the user modifies and saves plugin settings in TouchPortal."] # [doc = r""] # [doc = r" This method is triggered when TouchPortal sends a settings update message containing"] # [doc = r" the complete current state of all plugin settings. Use this to synchronize your"] # [doc = r" plugin's internal configuration with user-modified settings."] # [doc = r""] # [doc = r" You will generally want to take the `settings` argument using exhaustive"] # [doc = r" struct-destructure syntax (i.e., `PluginSettings { field1, field2: _ }`) so that the"] # [doc = r" compiler will remind you to update the method if new settings are added."] # [doc = r""] # [doc = r" Remember that this will also be triggered when read-only settings are updated, even"] # [doc = r" though they're updated _by the plugin_. You'll probably want to ignore updates to"] # [doc = r" such settings."] # [doc = r""] # [doc = r" # Arguments"] # [doc = r" * `settings` - The complete current plugin settings parsed into the generated `PluginSettings` struct"] # [doc = r""] # [doc = r" # Example"] # [doc = r" ```rust,ignore"] # [doc = r" async fn on_settings_changed(&mut self, settings: PluginSettings { api_key, another_setting: _ }) -> eyre::Result<()> {"] # [doc = r#"     tracing::info!(?settings, "settings updated by user");"#] # [doc = r""] # [doc = r"     // Update your plugin's internal state based on new settings"] # [doc = r"     self.api_client.update_credentials(&api_key)?;"] # [doc = r"     self.reconnect_if_needed().await?;"] # [doc = r""] # [doc = r"     Ok(())"] # [doc = r" }"] # [doc = r" ```"] async fn on_settings_changed (& mut self , settings : PluginSettings) -> eyre :: Result < () > ; } # [derive (Debug , Clone , serde :: Deserialize , serde :: Serialize)] # [allow (non_camel_case_types)] # [allow (non_snake_case)] pub enum ChoicesForChoiceData { # [serde (rename = "First")] First , # [serde (rename = "Second")] Second , # [doc = r" Used when a choice value has been dynamically created at runtime"] # [doc = r" using `update_choices_in*`."] # [serde (untagged)] Dynamic (String) } impl :: std :: fmt :: Display for ChoicesForChoiceData { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { write ! (f , "{}" , match self { Self :: First => "First" , Self :: Second => "Second" , Self :: Dynamic (other) => other , }) } } impl :: std :: str :: FromStr for ChoicesForChoiceData { type Err = eyre :: Report ; fn from_str (s : & str) -> :: eyre :: Result < Self > { match s { "First" => Ok (Self :: First) , "Second" => Ok (Self :: Second) , _ => Ok (Self :: Dynamic (s . to_string ())) , } } } impl protocol :: TouchPortalToString for ChoicesForChoiceData { fn stringify (& self) -> String { self . to_string () } } impl protocol :: TouchPortalFromStr for ChoicesForChoiceData { fn destringify (s : & str) -> eyre :: Result < Self > { :: std :: str :: FromStr :: from_str (s) } } # [allow (private_bounds)] impl Plugin where Self : PluginCallbacks { async fn handle_incoming (& mut self , msg : protocol :: TouchPortalOutput) -> eyre :: Result < bool > { use protocol :: TouchPortalOutput ; use :: eyre :: Context as _ ; match msg { TouchPortalOutput :: Info (_) => eyre :: bail ! ("got unexpected late info") , TouchPortalOutput :: Action (_) | TouchPortalOutput :: Up (_) | TouchPortalOutput :: Down (_) => { # [allow (unused_variables)] let (interaction_mode , action) = match msg { TouchPortalOutput :: Action (action) => (protocol :: ActionInteractionMode :: Execute , action) , TouchPortalOutput :: Down (action) => (protocol :: ActionInteractionMode :: HoldDown , action) , TouchPortalOutput :: Up (action) => (protocol :: ActionInteractionMode :: HoldUp , action) , _ => unreachable ! ("we would not have entered this outer match arm otherwise") , } ; # [allow (clippy :: match_single_binding)] match & * action . action_id { "test_action" => { # [allow (unused_mut)] let mut args : :: std :: collections :: HashMap < _ , _ > = action . data . into_iter () . map (| idv | (idv . id , idv . value)) . collect () ; :: tracing :: trace ! (? args , concat ! ("action " , "test_action" , " called")) ; let text_data : String = { let arg = args . remove (stringify ! (text_data)) . ok_or_else (|| eyre :: eyre ! (concat ! ("action " , "test_action" , " called without argument " , stringify ! (text_data)))) ? ; protocol :: TouchPortalFromStr :: destringify (& arg) . context (concat ! ("action " , "test_action" , " called with incorrectly typed argument " , stringify ! (text_data))) ? } ; let choice_data : ChoicesForChoiceData = { let arg = args . remove (stringify ! (choice_data)) . ok_or_else (|| eyre :: eyre ! (concat ! ("action " , "test_action" , " called without argument " , stringify ! (choice_data)))) ? ; protocol :: TouchPortalFromStr :: destringify (& arg) . context (concat ! ("action " , "test_action" , " called with incorrectly typed argument " , stringify ! (choice_data))) ? } ; self . on_test_action (interaction_mode , text_data , choice_data) . await . context (concat ! ("handle " , "test_action" , " action")) ? } id => eyre :: bail ! ("action executed with unknown action id {id}") , } } , TouchPortalOutput :: ConnectorChange (change) => { :: tracing :: error ! (? change , "connector changes are not yet implemented") ; } , TouchPortalOutput :: ShortConnectorIdNotification (assoc) => { :: tracing :: error ! (? assoc , "short connector id support are not yet implemented") ; } TouchPortalOutput :: ListChange (change) => { # [allow (clippy :: match_single_binding)] match (& * change . list_id , & * change . action_id) { ("choice_data" , "test_action") => { let value : ChoicesForChoiceData = protocol :: TouchPortalFromStr :: destringify (& change . value) . with_context (|| format ! (concat ! ("list change for choice " , "choice_data" , " called with incorrectly typed select value '{}'") , change . value)) ? ; self . on_select_choice_data_in_test_action (change . instance_id , value) . await . context (concat ! ("handle " , "choice_data" , " list change")) ? ; } , ("choice_data" , aid) => eyre :: bail ! ("list with known id '{}' changed, but with unexpected action id '{aid}'" , change . list_id) , (lid , "test_action") => eyre :: bail ! ("unknown list with id '{lid}' changed in known action '{}'" , change . action_id) , (lid , aid) => eyre :: bail ! ("unknown list '{lid}' in unknown action '{aid}' changed") , } } TouchPortalOutput :: ClosePlugin (_) => { self . on_close (false) . await . context ("handle graceful plugin close") ? ; return Ok (true) ; } , TouchPortalOutput :: Broadcast (event) => { self . on_broadcast (event) . await . context ("handle broadcast event") ? ; } , TouchPortalOutput :: NotificationOptionClicked (event) => { self . on_notification_clicked (event) . await . context ("handle notification click") ? ; } TouchPortalOutput :: Settings (settings_msg) => { let settings = PluginSettings :: from_settings_message (settings_msg) . context ("parse settings from message") ? ; self . on_settings_changed (settings) . await . context ("handle settings change") ? ; } _ => unimplemented ! ("codegen macro must be updated to handle {msg:?}") , } Ok (false) } }
