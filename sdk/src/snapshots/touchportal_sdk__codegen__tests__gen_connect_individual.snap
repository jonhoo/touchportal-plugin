---
source: sdk/src/codegen.rs
assertion_line: 1535
expression: connect_code.to_string()
---
impl Plugin where Self : PluginCallbacks { pub async fn run_dynamic (addr : impl tokio :: net :: ToSocketAddrs) -> eyre :: Result < () > { Self :: run_dynamic_with_setup (addr , std :: convert :: identity) . await } pub async fn run_dynamic_with_setup (addr : impl tokio :: net :: ToSocketAddrs , mutate : impl FnOnce (Plugin) -> Plugin ,) -> eyre :: Result < () > { use protocol :: * ; use :: eyre :: Context as _ ; use :: tokio :: io :: { AsyncBufReadExt , AsyncWriteExt } ; :: tracing :: info ! ("connect to TouchPortal") ; let mut connection = tokio :: net :: TcpStream :: connect (addr) . await . context ("connect to TouchPortal host") ? ; :: tracing :: info ! ("connected to TouchPortal") ; let (read , write) = connection . split () ; let mut writer = tokio :: io :: BufWriter :: new (write) ; let mut reader = tokio :: io :: BufReader :: new (read) ; :: tracing :: debug ! ("connected to TouchPortal") ; let mut json = serde_json :: to_string (& TouchPortalCommand :: Pair (PairCommand { id : "com.test.connect" . to_string () , }) ,) . context ("write out pair command") ? ; :: tracing :: trace ! (? json , "send") ; json . push ('\n') ; writer . write_all (json . as_bytes ()) . await . context ("send trailing newline") ? ; writer . flush () . await . context ("flush pair command") ? ; :: tracing :: debug ! ("await info response") ; let mut line = String :: new () ; let n = reader . read_line (& mut line) . await . context ("retrieve plugin info from server") ? ; if n == 0 { eyre :: bail ! ("TouchPortal closed connection on pair") ; } let json = serde_json :: from_str (& line) . context ("parse plugin info from server") ? ; :: tracing :: trace ! (? json , "recv") ; let output : TouchPortalOutput = serde_json :: from_value (json) . context ("parse as TouchPortalOutput") ? ; let TouchPortalOutput :: Info (mut info) = output else { eyre :: bail ! ("did not receive info in response to pair, got {output:?}") ; } ; let settings = if info . settings . is_empty () { :: tracing :: debug ! ("use default settings") ; PluginSettings :: default () } else { :: tracing :: debug ! ("parse customized settings") ; PluginSettings :: from_info_settings (std :: mem :: take (& mut info . settings)) . context ("parse settings from info") ? } ; :: tracing :: debug ! ("construct Plugin proper") ; let (send_outgoing , mut outgoing) = tokio :: sync :: mpsc :: channel (32) ; let plugin = Self :: new (settings , TouchPortalHandle (send_outgoing) , info) . await . context ("Plugin::new") ? ; let mut plugin = mutate (plugin) ; let mut line = String :: new () ; let mut out_buf = Vec :: new () ; loop { tokio :: select ! { n = reader . read_line (& mut line) => { let n = n . context ("read incoming message from TouchPortal") ? ; if n == 0 { :: tracing :: warn ! ("incoming channel from TouchPortal terminated") ; plugin . on_close (true) . await . context ("handle server-side EOF") ? ; break ; } let json : serde_json :: Value = serde_json :: from_str (& line) . context ("parse JSON from TouchPortal") ? ; let kind = json ["type"] . to_string () ; :: tracing :: trace ! (? json , "recv") ; let msg : TouchPortalOutput = serde_json :: from_value (json) . context ("parse as TouchPortalOutput") ? ; let should_exit = plugin . handle_incoming (msg) . await . with_context (|| format ! ("respond to {kind}")) ? ; if should_exit { :: tracing :: info ! ("plugin received close signal, exiting gracefully") ; break ; } line . clear () ; } cmd = outgoing . recv () , if ! outgoing . is_closed () => { let Some (cmd) = cmd else { :: tracing :: warn ! ("outgoing channel to TouchPortal terminated") ; break ; } ; serde_json :: to_writer (& mut out_buf , & cmd) . context ("serialize outgoing command") ? ; let json = std :: str :: from_utf8 (& out_buf) . expect ("JSON is valid UTF-8") ; :: tracing :: trace ! (? json , "send") ; out_buf . push (b'\n') ; writer . write_all (& out_buf) . await . context ("send outgoing command to TouchPortal") ? ; writer . flush () . await . context ("flush outgoing command") ? ; out_buf . clear () ; } } ; } Ok (()) } }
