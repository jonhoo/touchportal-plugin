---
source: sdk/src/codegen.rs
expression: formatted
---
#[allow(private_bounds)]
impl Plugin
where
    Self: PluginCallbacks,
{
    /// Run a dynamic plugin against TouchPortal running at the given `addr`.
    ///
    /// `constructor` is used to construct the [`Plugin`] type. This is generic to allow
    /// callers to make last-minute adjustments to `Plugin` before we start using it for
    /// real. Handy for injecting references to things like mock expectations.
    ///
    /// `constructor` will block all I/O with TouchPortal, so until that future resolves,
    /// any I/O events sent to TouchPortal will not be sent, and any I/O events received
    /// from TouchPortal will not be relayed (since there's nowhere to relay them _to_).
    ///
    /// The last argument to `constructor` is a handle for sending self-triggered events to
    /// the plugin (i.e., ones that originate from outside of TouchPortal).
    pub async fn run_dynamic_with<C>(
        addr: impl ::tokio::net::ToSocketAddrs,
        constructor: C,
    ) -> eyre::Result<()>
    where
        C: AsyncFnOnce(
            PluginSettings,
            TouchPortalHandle,
            InfoMessage,
            ::tokio::sync::mpsc::Sender<<Self as PluginCallbacks>::SelfTriggered>,
        ) -> eyre::Result<Self>,
    {
        use protocol::*;
        use ::eyre::Context as _;
        use ::tokio::io::{AsyncBufReadExt, AsyncWriteExt};
        ::tracing::info!("connect to TouchPortal");
        let mut connection = tokio::net::TcpStream::connect(addr)
            .await
            .context("connect to TouchPortal host")?;
        ::tracing::info!("connected to TouchPortal");
        let (read, write) = connection.split();
        let mut writer = ::tokio::io::BufWriter::new(write);
        let mut reader = ::tokio::io::BufReader::new(read);
        let (self_trigger, mut self_triggered) = ::tokio::sync::mpsc::channel(32);
        ::tracing::debug!("connected to TouchPortal");
        let mut json = serde_json::to_string(
                &TouchPortalCommand::Pair(PairCommand {
                    id: "com.test.connect".to_string(),
                }),
            )
            .context("write out pair command")?;
        ::tracing::trace!(? json, "send");
        json.push('\n');
        writer.write_all(json.as_bytes()).await.context("send trailing newline")?;
        writer.flush().await.context("flush pair command")?;
        ::tracing::debug!("await info response");
        let mut line = String::new();
        let n = reader
            .read_line(&mut line)
            .await
            .context("retrieve plugin info from server")?;
        if n == 0 {
            eyre::bail!("TouchPortal closed connection on pair");
        }
        let json = serde_json::from_str(&line).context("parse plugin info from server")?;
        ::tracing::trace!(? json, "recv");
        let output: TouchPortalOutput = serde_json::from_value(json)
            .context("parse as TouchPortalOutput")?;
        let TouchPortalOutput::Info(mut info) = output else {
            eyre::bail!("did not receive info in response to pair, got {output:?}");
        };
        let settings = if info.settings.is_empty() {
            ::tracing::debug!("use default settings");
            PluginSettings::default()
        } else {
            ::tracing::debug!("parse customized settings");
            PluginSettings::from_info_settings(std::mem::take(&mut info.settings))
                .context("parse settings from info")?
        };
        ::tracing::debug!("construct Plugin proper");
        let (send_outgoing, mut outgoing) = ::tokio::sync::mpsc::channel(32);
        let mut plugin = constructor(
                settings,
                TouchPortalHandle(send_outgoing),
                info,
                self_trigger,
            )
            .await
            .context("run Plugin constructor")?;
        let mut line = String::new();
        let mut out_buf = Vec::new();
        loop {
            ::tokio::select! {
                n = reader.read_line(& mut line) => { let n = n
                .context("read incoming message from TouchPortal") ?; if n == 0 {
                ::tracing::warn!("incoming channel from TouchPortal terminated"); plugin
                .on_close(true). await .context("handle server-side EOF") ?; break; } let
                json : serde_json::Value = serde_json::from_str(& line)
                .context("parse JSON from TouchPortal") ?; let kind = json["type"]
                .to_string(); ::tracing::trace!(? json, "recv"); let msg :
                TouchPortalOutput = serde_json::from_value(json)
                .context("parse as TouchPortalOutput") ?; let should_exit = plugin
                .handle_incoming(msg). await .with_context(||
                format!("respond to {kind}")) ?; if should_exit {
                ::tracing::info!("plugin received close signal, exiting gracefully");
                break; } line.clear(); } cmd = outgoing.recv(), if ! outgoing.is_closed()
                => { let Some(cmd) = cmd else {
                ::tracing::warn!("outgoing channel to TouchPortal terminated"); break; };
                serde_json::to_writer(& mut out_buf, & cmd)
                .context("serialize outgoing command") ?; let json =
                std::str::from_utf8(& out_buf).expect("JSON is valid UTF-8");
                ::tracing::trace!(? json, "send"); out_buf.push(b'\n'); writer
                .write_all(& out_buf). await
                .context("send outgoing command to TouchPortal") ?; writer.flush(). await
                .context("flush outgoing command") ?; out_buf.clear(); } event =
                self_triggered.recv(), if ! self_triggered.is_closed() => { if let
                Some(event) = event { plugin.on_self_triggered(event). await
                .context("process self-triggered event") ?; } }
            };
        }
        Ok(())
    }
}
