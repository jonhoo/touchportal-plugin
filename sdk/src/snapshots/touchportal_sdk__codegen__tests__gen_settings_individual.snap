---
source: sdk/src/codegen.rs
expression: settings_code
---
# [doc = "Valid choices for setting [`choice_setting`]"] # [derive (Debug , Clone , Copy , serde :: Deserialize)] pub enum ChoiceSettingSettingOptions { # [serde (rename = "Option A")] OptionA , # [serde (rename = "Option B")] OptionB , # [serde (rename = "Option C")] OptionC } impl :: std :: fmt :: Display for ChoiceSettingSettingOptions { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { write ! (f , "{}" , match self { Self :: OptionA => "Option A" , Self :: OptionB => "Option B" , Self :: OptionC => "Option C" }) } } impl :: std :: str :: FromStr for ChoiceSettingSettingOptions { type Err = eyre :: Report ; fn from_str (s : & str) -> :: eyre :: Result < Self > { match s { "Option A" => Ok (Self :: OptionA) , "Option B" => Ok (Self :: OptionB) , "Option C" => Ok (Self :: OptionC) , _ => eyre :: bail ! ("'{s}' is not a valid setting value") , } } } impl protocol :: TouchPortalToString for ChoiceSettingSettingOptions { fn stringify (& self) -> String { self . to_string () } } impl protocol :: TouchPortalFromStr for ChoiceSettingSettingOptions { fn destringify (s : & str) -> eyre :: Result < Self > { :: std :: str :: FromStr :: from_str (s) } } fn defaults_for_setting_text_setting () -> String { protocol :: TouchPortalFromStr :: destringify ("default_text") . expect (concat ! ("initial value '" , "default_text" , "' is valid for setting `" , "text_setting" , "`")) } fn defaults_for_setting_choice_setting () -> ChoiceSettingSettingOptions { protocol :: TouchPortalFromStr :: destringify ("Option A") . expect (concat ! ("initial value '" , "Option A" , "' is valid for setting `" , "choice_setting" , "`")) } fn defaults_for_setting_number_setting () -> f64 { protocol :: TouchPortalFromStr :: destringify ("42") . expect (concat ! ("initial value '" , "42" , "' is valid for setting `" , "number_setting" , "`")) } fn defaults_for_setting_switch_setting () -> bool { protocol :: TouchPortalFromStr :: destringify ("On") . expect (concat ! ("initial value '" , "On" , "' is valid for setting `" , "switch_setting" , "`")) } # [derive (Debug , Clone , serde :: Deserialize)] pub struct PluginSettings { # [serde (with = "protocol::serde_tp_stringly")] # [serde (rename = "text_setting" , default = "defaults_for_setting_text_setting")] text_setting : String , # [serde (with = "protocol::serde_tp_stringly")] # [serde (rename = "choice_setting" , default = "defaults_for_setting_choice_setting")] choice_setting : ChoiceSettingSettingOptions , # [serde (with = "protocol::serde_tp_stringly")] # [serde (rename = "number_setting" , default = "defaults_for_setting_number_setting")] number_setting : f64 , # [serde (with = "protocol::serde_tp_stringly")] # [serde (rename = "switch_setting" , default = "defaults_for_setting_switch_setting")] switch_setting : bool } # [automatically_derived] impl Default for PluginSettings { fn default () -> Self { Self { text_setting : defaults_for_setting_text_setting () , choice_setting : defaults_for_setting_choice_setting () , number_setting : defaults_for_setting_number_setting () , switch_setting : defaults_for_setting_switch_setting () } } } impl PluginSettings { pub fn from_info_settings (info : Vec < :: std :: collections :: HashMap < String , :: serde_json :: Value >>) -> :: eyre :: Result < Self > { use :: eyre :: Context as _ ; let value = info . into_iter () . flatten () . collect () ; serde_json :: from_value (value) . context ("parse settings") } pub fn from_settings_message (settings : protocol :: SettingsMessage) -> :: eyre :: Result < Self > { use :: eyre :: Context as _ ; let value = settings . values . into_iter () . flatten () . collect () ; serde_json :: from_value (value) . context ("parse settings message") } }
