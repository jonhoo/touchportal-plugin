---
source: sdk/src/codegen.rs
expression: formatted
---
///Valid choices for setting [`choice_setting`]
#[derive(Debug, Clone, Copy, serde::Deserialize)]
pub enum ChoiceSettingSettingOptions {
    #[serde(rename = "option_a")]
    OptionA,
    #[serde(rename = "option_b")]
    OptionB,
    #[serde(rename = "option_c")]
    OptionC,
}
impl ::std::fmt::Display for ChoiceSettingSettingOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f, "{}", match self { Self::OptionA => "option_a", Self::OptionB =>
            "option_b", Self::OptionC => "option_c" }
        )
    }
}
impl ::std::str::FromStr for ChoiceSettingSettingOptions {
    type Err = eyre::Report;
    fn from_str(s: &str) -> ::eyre::Result<Self> {
        match s {
            "option_a" => Ok(Self::OptionA),
            "option_b" => Ok(Self::OptionB),
            "option_c" => Ok(Self::OptionC),
            _ => eyre::bail!("'{s}' is not a valid setting value"),
        }
    }
}
impl protocol::TouchPortalToString for ChoiceSettingSettingOptions {
    fn stringify(&self) -> String {
        self.to_string()
    }
}
impl protocol::TouchPortalFromStr for ChoiceSettingSettingOptions {
    fn destringify(s: &str) -> eyre::Result<Self> {
        ::std::str::FromStr::from_str(s)
    }
}
fn defaults_for_setting_text_setting() -> String {
    protocol::TouchPortalFromStr::destringify("default_text")
        .expect(
            concat!(
                "initial value '", "default_text", "' is valid for setting `",
                "text_setting", "`"
            ),
        )
}
fn defaults_for_setting_switch_setting() -> bool {
    protocol::TouchPortalFromStr::destringify("Off")
        .expect(
            concat!(
                "initial value '", "Off", "' is valid for setting `", "switch_setting",
                "`"
            ),
        )
}
fn defaults_for_setting_choice_setting() -> ChoiceSettingSettingOptions {
    protocol::TouchPortalFromStr::destringify("option_a")
        .expect(
            concat!(
                "initial value '", "option_a", "' is valid for setting `",
                "choice_setting", "`"
            ),
        )
}
#[derive(Debug, Clone, serde::Deserialize)]
pub struct PluginSettings {
    #[serde(with = "protocol::serde_tp_stringly")]
    #[serde(rename = "text_setting", default = "defaults_for_setting_text_setting")]
    text_setting: String,
    #[serde(with = "protocol::serde_tp_stringly")]
    #[serde(rename = "switch_setting", default = "defaults_for_setting_switch_setting")]
    switch_setting: bool,
    #[serde(with = "protocol::serde_tp_stringly")]
    #[serde(rename = "choice_setting", default = "defaults_for_setting_choice_setting")]
    choice_setting: ChoiceSettingSettingOptions,
}
#[automatically_derived]
impl Default for PluginSettings {
    fn default() -> Self {
        Self {
            text_setting: defaults_for_setting_text_setting(),
            switch_setting: defaults_for_setting_switch_setting(),
            choice_setting: defaults_for_setting_choice_setting(),
        }
    }
}
impl PluginSettings {
    pub fn from_info_settings(
        info: Vec<::std::collections::HashMap<String, ::serde_json::Value>>,
    ) -> ::eyre::Result<Self> {
        use ::eyre::Context as _;
        let value = info.into_iter().flatten().collect();
        serde_json::from_value(value).context("parse settings")
    }
    pub fn from_settings_message(
        settings: protocol::SettingsMessage,
    ) -> ::eyre::Result<Self> {
        use ::eyre::Context as _;
        let value = settings.values.into_iter().flatten().collect();
        serde_json::from_value(value).context("parse settings message")
    }
}
