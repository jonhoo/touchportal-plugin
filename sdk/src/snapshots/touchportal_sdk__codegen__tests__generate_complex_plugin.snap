---
source: sdk/src/codegen.rs
expression: generated
---
use ::touchportal_sdk::protocol;
///Valid choices for setting [`complex_choice`]
#[derive(Debug, Clone, Copy, serde::Deserialize)]
pub enum ComplexChoiceSettingOptions {
    #[serde(rename = "Advanced")]
    Advanced,
    #[serde(rename = "Default")]
    Default,
    #[serde(rename = "Expert")]
    Expert,
}
impl ::std::fmt::Display for ComplexChoiceSettingOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f, "{}", match self { Self::Advanced => "Advanced", Self::Default =>
            "Default", Self::Expert => "Expert" }
        )
    }
}
impl ::std::str::FromStr for ComplexChoiceSettingOptions {
    type Err = eyre::Report;
    fn from_str(s: &str) -> ::eyre::Result<Self> {
        match s {
            "Advanced" => Ok(Self::Advanced),
            "Default" => Ok(Self::Default),
            "Expert" => Ok(Self::Expert),
            _ => eyre::bail!("'{s}' is not a valid setting value"),
        }
    }
}
impl protocol::TouchPortalToString for ComplexChoiceSettingOptions {
    fn stringify(&self) -> String {
        self.to_string()
    }
}
impl protocol::TouchPortalFromStr for ComplexChoiceSettingOptions {
    fn destringify(s: &str) -> eyre::Result<Self> {
        ::std::str::FromStr::from_str(s)
    }
}
fn defaults_for_setting_complex_choice() -> ComplexChoiceSettingOptions {
    protocol::TouchPortalFromStr::destringify("Default")
        .expect(
            concat!(
                "initial value '", "Default", "' is valid for setting `",
                "complex_choice", "`"
            ),
        )
}
#[derive(Debug, Clone, serde::Deserialize)]
pub struct PluginSettings {
    ///Complexity Level
    ///
    ///Choose your preferred complexity level
    ///
    ///https://example.com/docs
    #[serde(with = "protocol::serde_tp_stringly")]
    #[serde(rename = "complex_choice", default = "defaults_for_setting_complex_choice")]
    complex_choice: ComplexChoiceSettingOptions,
}
#[automatically_derived]
impl Default for PluginSettings {
    fn default() -> Self {
        Self {
            complex_choice: defaults_for_setting_complex_choice(),
        }
    }
}
impl PluginSettings {
    pub fn from_info_settings(
        info: Vec<::std::collections::HashMap<String, ::serde_json::Value>>,
    ) -> ::eyre::Result<Self> {
        use ::eyre::Context as _;
        let value = info.into_iter().flatten().collect();
        serde_json::from_value(value).context("parse settings")
    }
    pub fn from_settings_message(
        settings: protocol::SettingsMessage,
    ) -> ::eyre::Result<Self> {
        use ::eyre::Context as _;
        let value = settings.values.into_iter().flatten().collect();
        serde_json::from_value(value).context("parse settings message")
    }
}
#[allow(private_bounds)]
impl Plugin
where
    Self: PluginCallbacks,
{
    /// Run a dynamic plugin against TouchPortal running at the given `addr`.
    ///
    /// `constructor` is used to construct the [`Plugin`] type. This is generic to allow
    /// callers to make last-minute adjustments to `Plugin` before we start using it for
    /// real. Handy for injecting references to things like mock expectations.
    pub async fn run_dynamic_with<C>(
        addr: impl tokio::net::ToSocketAddrs,
        constructor: C,
    ) -> eyre::Result<()>
    where
        C: AsyncFnOnce(
            PluginSettings,
            TouchPortalHandle,
            InfoMessage,
        ) -> eyre::Result<Self>,
    {
        use protocol::*;
        use ::eyre::Context as _;
        use ::tokio::io::{AsyncBufReadExt, AsyncWriteExt};
        ::tracing::info!("connect to TouchPortal");
        let mut connection = tokio::net::TcpStream::connect(addr)
            .await
            .context("connect to TouchPortal host")?;
        ::tracing::info!("connected to TouchPortal");
        let (read, write) = connection.split();
        let mut writer = tokio::io::BufWriter::new(write);
        let mut reader = tokio::io::BufReader::new(read);
        ::tracing::debug!("connected to TouchPortal");
        let mut json = serde_json::to_string(
                &TouchPortalCommand::Pair(PairCommand {
                    id: "com.test.complex".to_string(),
                }),
            )
            .context("write out pair command")?;
        ::tracing::trace!(? json, "send");
        json.push('\n');
        writer.write_all(json.as_bytes()).await.context("send trailing newline")?;
        writer.flush().await.context("flush pair command")?;
        ::tracing::debug!("await info response");
        let mut line = String::new();
        let n = reader
            .read_line(&mut line)
            .await
            .context("retrieve plugin info from server")?;
        if n == 0 {
            eyre::bail!("TouchPortal closed connection on pair");
        }
        let json = serde_json::from_str(&line).context("parse plugin info from server")?;
        ::tracing::trace!(? json, "recv");
        let output: TouchPortalOutput = serde_json::from_value(json)
            .context("parse as TouchPortalOutput")?;
        let TouchPortalOutput::Info(mut info) = output else {
            eyre::bail!("did not receive info in response to pair, got {output:?}");
        };
        let settings = if info.settings.is_empty() {
            ::tracing::debug!("use default settings");
            PluginSettings::default()
        } else {
            ::tracing::debug!("parse customized settings");
            PluginSettings::from_info_settings(std::mem::take(&mut info.settings))
                .context("parse settings from info")?
        };
        ::tracing::debug!("construct Plugin proper");
        let (send_outgoing, mut outgoing) = tokio::sync::mpsc::channel(32);
        let mut plugin = constructor(settings, TouchPortalHandle(send_outgoing), info)
            .await
            .context("run Plugin constructor")?;
        let mut line = String::new();
        let mut out_buf = Vec::new();
        loop {
            tokio::select! {
                n = reader.read_line(& mut line) => { let n = n
                .context("read incoming message from TouchPortal") ?; if n == 0 {
                ::tracing::warn!("incoming channel from TouchPortal terminated"); plugin
                .on_close(true). await .context("handle server-side EOF") ?; break; } let
                json : serde_json::Value = serde_json::from_str(& line)
                .context("parse JSON from TouchPortal") ?; let kind = json["type"]
                .to_string(); ::tracing::trace!(? json, "recv"); let msg :
                TouchPortalOutput = serde_json::from_value(json)
                .context("parse as TouchPortalOutput") ?; let should_exit = plugin
                .handle_incoming(msg). await .with_context(||
                format!("respond to {kind}")) ?; if should_exit {
                ::tracing::info!("plugin received close signal, exiting gracefully");
                break; } line.clear(); } cmd = outgoing.recv(), if ! outgoing.is_closed()
                => { let Some(cmd) = cmd else {
                ::tracing::warn!("outgoing channel to TouchPortal terminated"); break; };
                serde_json::to_writer(& mut out_buf, & cmd)
                .context("serialize outgoing command") ?; let json =
                std::str::from_utf8(& out_buf).expect("JSON is valid UTF-8");
                ::tracing::trace!(? json, "send"); out_buf.push(b'\n'); writer
                .write_all(& out_buf). await
                .context("send outgoing command to TouchPortal") ?; writer.flush(). await
                .context("flush outgoing command") ?; out_buf.clear(); }
            };
        }
        Ok(())
    }
}
#[derive(Clone, Debug)]
pub struct TouchPortalHandle(::tokio::sync::mpsc::Sender<protocol::TouchPortalCommand>);
impl TouchPortalHandle {
    /// As a plug-in developer you can alert your users within Touch Portal for certain events.
    ///
    /// This system should only be used for important messages that the user has to act on. Examples
    /// are new updates for the plugin or changing settings like credentials. Maybe your user has set
    /// up the plug-in incorrectly which is also a good reason to send a notification to alert them to
    /// the issue and propose a solution.
    ///
    /// <div class="warning">
    ///
    /// **Rules of notifications**
    ///
    /// You are only allowed to send user critical notifications to help them on their way.
    /// Advertisements, donation request and all other non-essential messages are not allowed and may
    /// result in your plug-in be blacklisted from the notification center.
    ///
    /// </div>
    pub async fn notify(&mut self, cmd: protocol::CreateNotificationCommand) {
        let _ = self.0.send(protocol::TouchPortalCommand::CreateNotification(cmd)).await;
    }
    /// Create a state at runtime.
    pub async fn create_state(&mut self, cmd: protocol::CreateStateCommand) {
        let _ = self.0.send(protocol::TouchPortalCommand::CreateState(cmd)).await;
    }
    /// Remove a state at runtime.
    pub async fn remove_state(&mut self, id: impl Into<String>) {
        let _ = self
            .0
            .send(
                protocol::TouchPortalCommand::RemoveState(
                    protocol::RemoveStateCommand::builder().id(id).build().unwrap(),
                ),
            )
            .await;
    }
    ///When value becomes `$val`
    ///
    ///Since this value contains `$val`, you probably do not want
    ///to trigger it manually as the current value of the associated
    ///state may not match the user's set `$val` (and TouchPortal
    ///won't check against `$val`).
    ///
    ///Arguments:
    ///
    ///- `timestamp`: Change Timestamp
    pub async fn force_trigger_value_changed(
        &mut self,
        timestamp: impl protocol::TouchPortalToString,
    ) {
        let mut builder = protocol::TriggerEventCommand::builder();
        builder.state((String::from("timestamp"), timestamp.stringify()));
        let _ = self
            .0
            .send(
                protocol::TouchPortalCommand::TriggerEvent(
                    builder.event_id("value_changed").build().unwrap(),
                ),
            )
            .await;
    }
    ///Complexity Level
    ///
    ///Choose your preferred complexity level
    ///
    ///https://example.com/docs
    pub async fn set_complex_choice(&mut self, value: ComplexChoiceSettingOptions) {
        let _ = self
            .0
            .send(
                protocol::TouchPortalCommand::SettingUpdate(
                    protocol::UpdateSettingCommand::builder()
                        .name("complex_choice")
                        .value(value.to_string())
                        .build()
                        .unwrap(),
                ),
            )
            .await;
    }
}
impl TouchPortalHandle {
    ///Current status
    pub async fn update_status_state(&mut self, value: impl Into<String>) {
        let _ = self
            .0
            .send(
                protocol::TouchPortalCommand::StateUpdate(
                    protocol::UpdateStateCommand::builder()
                        .state_id("status_state")
                        .value(value.into())
                        .build()
                        .unwrap(),
                ),
            )
            .await;
    }
}
///Valid choices for [`update_value_state`]
#[derive(Debug, Clone, Copy)]
pub enum ValuesForStateValueState {
    Low,
    Medium,
    High,
}
impl ::std::fmt::Display for ValuesForStateValueState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f, "{}", match self { Self::Low => "Low", Self::Medium => "Medium",
            Self::High => "High" }
        )
    }
}
impl TouchPortalHandle {
    ///Current value level
    pub async fn update_value_state(&mut self, value: ValuesForStateValueState) {
        let _ = self
            .0
            .send(
                protocol::TouchPortalCommand::StateUpdate(
                    protocol::UpdateStateCommand::builder()
                        .state_id("value_state")
                        .value(value.to_string())
                        .build()
                        .unwrap(),
                ),
            )
            .await;
    }
}
#[diagnostic::on_unimplemented(
    message = "`{Self}` must implement `PluginCallbacks` to receive updates from TouchPortal ",
    label = "the trait `PluginCallbacks` is not implemented for `{Self}`",
    note = "Add `impl PluginCallbacks for {Self} {{}}` and let your IDE or the compiler guide you.",
    note = "This trait has methods for all possible \"incoming\" messages based on your plugin description in `build.rs`.",
)]
trait PluginCallbacks {
    async fn on_action_with_multiple_data(
        &mut self,
        mode: protocol::ActionInteractionMode,
        text_input: String,
        number_input: f64,
        switch_input: bool,
    ) -> eyre::Result<()>;
    async fn on_broadcast(
        &mut self,
        event: protocol::BroadcastEvent,
    ) -> eyre::Result<()> {
        tracing::debug!(? event, "on_broadcast noop");
        Ok(())
    }
    async fn on_close(&mut self, eof: bool) -> eyre::Result<()> {
        tracing::debug!(? eof, "on_close noop");
        Ok(())
    }
    async fn on_notification_clicked(
        &mut self,
        event: protocol::NotificationClickedMessage,
    ) -> eyre::Result<()> {
        tracing::debug!(? event, "on_notification_clicked noop");
        Ok(())
    }
    /// Called when the user modifies and saves plugin settings in TouchPortal.
    ///
    /// This method is triggered when TouchPortal sends a settings update message containing
    /// the complete current state of all plugin settings. Use this to synchronize your
    /// plugin's internal configuration with user-modified settings.
    ///
    /// You will generally want to take the `settings` argument using exhaustive
    /// struct-destructure syntax (i.e., `PluginSettings { field1, field2: _ }`) so that the
    /// compiler will remind you to update the method if new settings are added.
    ///
    /// Remember that this will also be triggered when read-only settings are updated, even
    /// though they're updated _by the plugin_. You'll probably want to ignore updates to
    /// such settings.
    ///
    /// # Arguments
    /// * `settings` - The complete current plugin settings parsed into the generated `PluginSettings` struct
    ///
    /// # Example
    /// ```rust,ignore
    /// async fn on_settings_changed(&mut self, settings: PluginSettings { api_key, another_setting: _ }) -> eyre::Result<()> {
    ///     tracing::info!(?settings, "settings updated by user");
    ///
    ///     // Update your plugin's internal state based on new settings
    ///     self.api_client.update_credentials(&api_key)?;
    ///     self.reconnect_if_needed().await?;
    ///
    ///     Ok(())
    /// }
    /// ```
    async fn on_settings_changed(
        &mut self,
        settings: PluginSettings,
    ) -> eyre::Result<()>;
}
#[allow(private_bounds)]
impl Plugin
where
    Self: PluginCallbacks,
{
    async fn handle_incoming(
        &mut self,
        msg: protocol::TouchPortalOutput,
    ) -> eyre::Result<bool> {
        use protocol::TouchPortalOutput;
        use ::eyre::Context as _;
        match msg {
            TouchPortalOutput::Info(_) => eyre::bail!("got unexpected late info"),
            TouchPortalOutput::Action(_)
            | TouchPortalOutput::Up(_)
            | TouchPortalOutput::Down(_) => {
                #[allow(unused_variables)]
                let (interaction_mode, action) = match msg {
                    TouchPortalOutput::Action(action) => {
                        (protocol::ActionInteractionMode::Execute, action)
                    }
                    TouchPortalOutput::Down(action) => {
                        (protocol::ActionInteractionMode::HoldDown, action)
                    }
                    TouchPortalOutput::Up(action) => {
                        (protocol::ActionInteractionMode::HoldUp, action)
                    }
                    _ => {
                        unreachable!(
                            "we would not have entered this outer match arm otherwise"
                        )
                    }
                };
                #[allow(clippy::match_single_binding)]
                match &*action.action_id {
                    "action_with_multiple_data" => {
                        #[allow(unused_mut)]
                        let mut args: ::std::collections::HashMap<_, _> = action
                            .data
                            .into_iter()
                            .map(|idv| (idv.id, idv.value))
                            .collect();
                        ::tracing::trace!(
                            ? args, concat!("action ", "action_with_multiple_data",
                            " called")
                        );
                        let text_input: String = {
                            let arg = args
                                .remove(stringify!(text_input))
                                .ok_or_else(|| {
                                    eyre::eyre!(
                                        concat!("action ", "action_with_multiple_data",
                                        " called without argument ", stringify!(text_input))
                                    )
                                })?;
                            protocol::TouchPortalFromStr::destringify(&arg)
                                .context(
                                    concat!(
                                        "action ", "action_with_multiple_data",
                                        " called with incorrectly typed argument ",
                                        stringify!(text_input)
                                    ),
                                )?
                        };
                        let number_input: f64 = {
                            let arg = args
                                .remove(stringify!(number_input))
                                .ok_or_else(|| {
                                    eyre::eyre!(
                                        concat!("action ", "action_with_multiple_data",
                                        " called without argument ", stringify!(number_input))
                                    )
                                })?;
                            protocol::TouchPortalFromStr::destringify(&arg)
                                .context(
                                    concat!(
                                        "action ", "action_with_multiple_data",
                                        " called with incorrectly typed argument ",
                                        stringify!(number_input)
                                    ),
                                )?
                        };
                        let switch_input: bool = {
                            let arg = args
                                .remove(stringify!(switch_input))
                                .ok_or_else(|| {
                                    eyre::eyre!(
                                        concat!("action ", "action_with_multiple_data",
                                        " called without argument ", stringify!(switch_input))
                                    )
                                })?;
                            protocol::TouchPortalFromStr::destringify(&arg)
                                .context(
                                    concat!(
                                        "action ", "action_with_multiple_data",
                                        " called with incorrectly typed argument ",
                                        stringify!(switch_input)
                                    ),
                                )?
                        };
                        self.on_action_with_multiple_data(
                                interaction_mode,
                                text_input,
                                number_input,
                                switch_input,
                            )
                            .await
                            .context(
                                concat!("handle ", "action_with_multiple_data", " action"),
                            )?
                    }
                    id => eyre::bail!("action executed with unknown action id {id}"),
                }
            }
            TouchPortalOutput::ConnectorChange(change) => {
                ::tracing::error!(? change, "connector changes are not yet implemented");
            }
            TouchPortalOutput::ShortConnectorIdNotification(assoc) => {
                ::tracing::error!(
                    ? assoc, "short connector id support are not yet implemented"
                );
            }
            TouchPortalOutput::ListChange(change) => {
                #[allow(clippy::match_single_binding)]
                match (&*change.list_id, &*change.action_id) {
                    (lid, aid) => {
                        eyre::bail!(
                            "unknown list '{lid}' in unknown action '{aid}' changed"
                        )
                    }
                }
            }
            TouchPortalOutput::ClosePlugin(_) => {
                self.on_close(false).await.context("handle graceful plugin close")?;
                return Ok(true);
            }
            TouchPortalOutput::Broadcast(event) => {
                self.on_broadcast(event).await.context("handle broadcast event")?;
            }
            TouchPortalOutput::NotificationOptionClicked(event) => {
                self.on_notification_clicked(event)
                    .await
                    .context("handle notification click")?;
            }
            TouchPortalOutput::Settings(settings_msg) => {
                let settings = PluginSettings::from_settings_message(settings_msg)
                    .context("parse settings from message")?;
                self.on_settings_changed(settings)
                    .await
                    .context("handle settings change")?;
            }
            _ => unimplemented!("codegen macro must be updated to handle {msg:?}"),
        }
        Ok(false)
    }
}
