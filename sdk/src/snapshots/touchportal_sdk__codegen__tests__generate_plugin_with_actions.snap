---
source: sdk/src/codegen.rs
expression: generated
---
use ::touchportal_sdk::protocol;
#[derive(Debug, Clone, serde::Deserialize)]
pub struct PluginSettings {}
#[automatically_derived]
impl Default for PluginSettings {
    fn default() -> Self {
        Self {}
    }
}
impl PluginSettings {
    pub fn from_info_settings(
        info: Vec<::std::collections::HashMap<String, ::serde_json::Value>>,
    ) -> ::eyre::Result<Self> {
        use ::eyre::Context as _;
        let value = info.into_iter().flatten().collect();
        serde_json::from_value(value).context("parse settings")
    }
    pub fn from_settings_message(
        settings: protocol::SettingsMessage,
    ) -> ::eyre::Result<Self> {
        use ::eyre::Context as _;
        let value = settings.values.into_iter().flatten().collect();
        serde_json::from_value(value).context("parse settings message")
    }
}
impl Plugin
where
    Self: PluginCallbacks,
{
    pub async fn run_dynamic(addr: impl tokio::net::ToSocketAddrs) -> eyre::Result<()> {
        Self::run_dynamic_with_setup(addr, std::convert::identity).await
    }
    pub async fn run_dynamic_with_setup(
        addr: impl tokio::net::ToSocketAddrs,
        mutate: impl FnOnce(Plugin) -> Plugin,
    ) -> eyre::Result<()> {
        use protocol::*;
        use ::eyre::Context as _;
        use ::tokio::io::{AsyncBufReadExt, AsyncWriteExt};
        ::tracing::info!("connect to TouchPortal");
        let mut connection = tokio::net::TcpStream::connect(addr)
            .await
            .context("connect to TouchPortal host")?;
        ::tracing::info!("connected to TouchPortal");
        let (read, write) = connection.split();
        let mut writer = tokio::io::BufWriter::new(write);
        let mut reader = tokio::io::BufReader::new(read);
        ::tracing::debug!("connected to TouchPortal");
        let mut json = serde_json::to_string(
                &TouchPortalCommand::Pair(PairCommand {
                    id: "com.test.actions".to_string(),
                }),
            )
            .context("write out pair command")?;
        ::tracing::trace!(? json, "send");
        json.push('\n');
        writer.write_all(json.as_bytes()).await.context("send trailing newline")?;
        writer.flush().await.context("flush pair command")?;
        ::tracing::debug!("await info response");
        let mut line = String::new();
        let n = reader
            .read_line(&mut line)
            .await
            .context("retrieve plugin info from server")?;
        if n == 0 {
            eyre::bail!("TouchPortal closed connection on pair");
        }
        let json = serde_json::from_str(&line).context("parse plugin info from server")?;
        ::tracing::trace!(? json, "recv");
        let output: TouchPortalOutput = serde_json::from_value(json)
            .context("parse as TouchPortalOutput")?;
        let TouchPortalOutput::Info(mut info) = output else {
            eyre::bail!("did not receive info in response to pair, got {output:?}");
        };
        let settings = if info.settings.is_empty() {
            ::tracing::debug!("use default settings");
            PluginSettings::default()
        } else {
            ::tracing::debug!("parse customized settings");
            PluginSettings::from_info_settings(std::mem::take(&mut info.settings))
                .context("parse settings from info")?
        };
        ::tracing::debug!("construct Plugin proper");
        let (send_outgoing, mut outgoing) = tokio::sync::mpsc::channel(32);
        let plugin = Self::new(settings, TouchPortalHandle(send_outgoing), info)
            .await
            .context("Plugin::new")?;
        let mut plugin = mutate(plugin);
        let mut line = String::new();
        let mut out_buf = Vec::new();
        loop {
            tokio::select! {
                n = reader.read_line(& mut line) => { let n = n
                .context("read incoming message from TouchPortal") ?; if n == 0 {
                ::tracing::warn!("incoming channel from TouchPortal terminated"); plugin
                .on_close(true). await .context("handle server-side EOF") ?; break; } let
                json : serde_json::Value = serde_json::from_str(& line)
                .context("parse JSON from TouchPortal") ?; let kind = json["type"]
                .to_string(); ::tracing::trace!(? json, "recv"); let msg :
                TouchPortalOutput = serde_json::from_value(json)
                .context("parse as TouchPortalOutput") ?; let should_exit = plugin
                .handle_incoming(msg). await .with_context(||
                format!("respond to {kind}")) ?; if should_exit {
                ::tracing::info!("plugin received close signal, exiting gracefully");
                break; } line.clear(); } cmd = outgoing.recv(), if ! outgoing.is_closed()
                => { let Some(cmd) = cmd else {
                ::tracing::warn!("outgoing channel to TouchPortal terminated"); break; };
                serde_json::to_writer(& mut out_buf, & cmd)
                .context("serialize outgoing command") ?; let json =
                std::str::from_utf8(& out_buf).expect("JSON is valid UTF-8");
                ::tracing::trace!(? json, "send"); out_buf.push(b'\n'); writer
                .write_all(& out_buf). await
                .context("send outgoing command to TouchPortal") ?; writer.flush(). await
                .context("flush outgoing command") ?; out_buf.clear(); }
            };
        }
        Ok(())
    }
}
#[derive(Clone, Debug)]
pub struct TouchPortalHandle(::tokio::sync::mpsc::Sender<protocol::TouchPortalCommand>);
impl TouchPortalHandle {
    /// As a plug-in developer you can alert your users within Touch Portal for certain events.
    ///
    /// This system should only be used for important messages that the user has to act on. Examples
    /// are new updates for the plugin or changing settings like credentials. Maybe your user has set
    /// up the plug-in incorrectly which is also a good reason to send a notification to alert them to
    /// the issue and propose a solution.
    ///
    /// <div class="warning">
    ///
    /// **Rules of notifications**
    ///
    /// You are only allowed to send user critical notifications to help them on their way.
    /// Advertisements, donation request and all other non-essential messages are not allowed and may
    /// result in your plug-in be blacklisted from the notification center.
    ///
    /// </div>
    pub async fn notify(&mut self, cmd: protocol::CreateNotificationCommand) {
        let _ = self.0.send(protocol::TouchPortalCommand::CreateNotification(cmd)).await;
    }
    /// Create a state at runtime.
    pub async fn create_state(&mut self, cmd: protocol::CreateStateCommand) {
        let _ = self.0.send(protocol::TouchPortalCommand::CreateState(cmd)).await;
    }
    /// Remove a state at runtime.
    pub async fn remove_state(&mut self, id: impl Into<String>) {
        let _ = self
            .0
            .send(
                protocol::TouchPortalCommand::RemoveState(
                    protocol::RemoveStateCommand::builder().id(id).build().unwrap(),
                ),
            )
            .await;
    }
    ///Updates the choice list for the action data field choice_data.
    pub async fn update_choices_in_choice_data(
        &mut self,
        choices: impl IntoIterator<Item = impl Into<String>>,
    ) {
        let _ = self
            .0
            .send(
                protocol::TouchPortalCommand::ChoiceUpdate(
                    protocol::ChoiceUpdateCommand::builder()
                        .id("choice_data")
                        .choices(choices.into_iter().map(Into::into).collect())
                        .build()
                        .unwrap(),
                ),
            )
            .await;
    }
    ///Updates the choice list for a particular instance of the action data field choice_data.
    ///
    ///Specifically, this will only update the choice list in the given action instance.
    ///You will generally get the instance from a call to one of the `on_select` methods.
    pub async fn update_choices_in_specific_choice_data(
        &mut self,
        instance: impl Into<String>,
        choices: impl IntoIterator<Item = impl Into<String>>,
    ) {
        let _ = self
            .0
            .send(
                protocol::TouchPortalCommand::ChoiceUpdate(
                    protocol::ChoiceUpdateCommand::builder()
                        .id("choice_data")
                        .choices(choices.into_iter().map(Into::into).collect())
                        .instance_id(instance)
                        .build()
                        .unwrap(),
                ),
            )
            .await;
    }
}
#[diagnostic::on_unimplemented(
    message = "`{Self}` must implement `PluginCallbacks` to receive updates from TouchPortal ",
    label = "the trait `PluginCallbacks` is not implemented for `{Self}`",
    note = "Add `impl PluginCallbacks for {Self} {{}}` and let your IDE or the compiler guide you.",
    note = "This trait has methods for all possible \"incoming\" messages based on your plugin description in `build.rs`.",
)]
trait PluginCallbacks {
    async fn on_test_action(
        &mut self,
        mode: protocol::ActionInteractionMode,
        text_data: String,
        choice_data: ChoicesForChoiceData,
    ) -> eyre::Result<()>;
    async fn on_select_choice_data_in_test_action(
        &mut self,
        instance: String,
        selected: ChoicesForChoiceData,
    ) -> eyre::Result<()>;
    async fn on_broadcast(
        &mut self,
        event: protocol::BroadcastEvent,
    ) -> eyre::Result<()> {
        tracing::debug!(? event, "on_broadcast noop");
        Ok(())
    }
    async fn on_close(&mut self, eof: bool) -> eyre::Result<()> {
        tracing::debug!(? eof, "on_close noop");
        Ok(())
    }
    async fn on_notification_clicked(
        &mut self,
        event: protocol::NotificationClickedMessage,
    ) -> eyre::Result<()> {
        tracing::debug!(? event, "on_notification_clicked noop");
        Ok(())
    }
    /// Called when the user modifies and saves plugin settings in TouchPortal.
    ///
    /// This method is triggered when TouchPortal sends a settings update message containing
    /// the complete current state of all plugin settings. Use this to synchronize your
    /// plugin's internal configuration with user-modified settings.
    ///
    /// # Arguments
    /// * `settings` - The complete current plugin settings parsed into the generated `PluginSettings` struct
    ///
    /// # Example
    /// ```rust,ignore
    /// async fn on_settings_changed(&mut self, settings: PluginSettings) -> eyre::Result<()> {
    ///     tracing::info!(?settings, "settings updated by user");
    ///
    ///     // Update your plugin's internal state based on new settings
    ///     self.api_client.update_credentials(&settings.api_key)?;
    ///     self.reconnect_if_needed().await?;
    ///
    ///     Ok(())
    /// }
    /// ```
    async fn on_settings_changed(
        &mut self,
        settings: PluginSettings,
    ) -> eyre::Result<()>;
}
#[derive(Debug, Clone, serde::Deserialize, serde::Serialize)]
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
pub enum ChoicesForChoiceData {
    #[serde(rename = "First")]
    First,
    #[serde(rename = "Second")]
    Second,
    /// Used when a choice value has been dynamically created at runtime
    /// using `update_choices_in*`.
    #[serde(untagged)]
    Dynamic(String),
}
impl ::std::fmt::Display for ChoicesForChoiceData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f, "{}", match self { Self::First => "First", Self::Second => "Second",
            Self::Dynamic(other) => other, }
        )
    }
}
impl ::std::str::FromStr for ChoicesForChoiceData {
    type Err = eyre::Report;
    fn from_str(s: &str) -> ::eyre::Result<Self> {
        match s {
            "First" => Ok(Self::First),
            "Second" => Ok(Self::Second),
            _ => Ok(Self::Dynamic(s.to_string())),
        }
    }
}
impl protocol::TouchPortalToString for ChoicesForChoiceData {
    fn stringify(&self) -> String {
        self.to_string()
    }
}
impl protocol::TouchPortalFromStr for ChoicesForChoiceData {
    fn destringify(s: &str) -> eyre::Result<Self> {
        ::std::str::FromStr::from_str(s)
    }
}
impl Plugin
where
    Self: PluginCallbacks,
{
    async fn handle_incoming(
        &mut self,
        msg: protocol::TouchPortalOutput,
    ) -> eyre::Result<bool> {
        use protocol::TouchPortalOutput;
        use ::eyre::Context as _;
        match msg {
            TouchPortalOutput::Info(_) => eyre::bail!("got unexpected late info"),
            TouchPortalOutput::Action(_)
            | TouchPortalOutput::Up(_)
            | TouchPortalOutput::Down(_) => {
                #[allow(unused_variables)]
                let (interaction_mode, action) = match msg {
                    TouchPortalOutput::Action(action) => {
                        (protocol::ActionInteractionMode::Execute, action)
                    }
                    TouchPortalOutput::Down(action) => {
                        (protocol::ActionInteractionMode::HoldDown, action)
                    }
                    TouchPortalOutput::Up(action) => {
                        (protocol::ActionInteractionMode::HoldUp, action)
                    }
                    _ => {
                        unreachable!(
                            "we would not have entered this outer match arm otherwise"
                        )
                    }
                };
                #[allow(clippy::match_single_binding)]
                match &*action.action_id {
                    "test_action" => {
                        #[allow(unused_mut)]
                        let mut args: ::std::collections::HashMap<_, _> = action
                            .data
                            .into_iter()
                            .map(|idv| (idv.id, idv.value))
                            .collect();
                        ::tracing::trace!(
                            ? args, concat!("action ", "test_action", " called")
                        );
                        let text_data: String = {
                            let arg = args
                                .remove(stringify!(text_data))
                                .ok_or_else(|| {
                                    eyre::eyre!(
                                        concat!("action ", "test_action",
                                        " called without argument ", stringify!(text_data))
                                    )
                                })?;
                            protocol::TouchPortalFromStr::destringify(&arg)
                                .context(
                                    concat!(
                                        "action ", "test_action",
                                        " called with incorrectly typed argument ",
                                        stringify!(text_data)
                                    ),
                                )?
                        };
                        let choice_data: ChoicesForChoiceData = {
                            let arg = args
                                .remove(stringify!(choice_data))
                                .ok_or_else(|| {
                                    eyre::eyre!(
                                        concat!("action ", "test_action",
                                        " called without argument ", stringify!(choice_data))
                                    )
                                })?;
                            protocol::TouchPortalFromStr::destringify(&arg)
                                .context(
                                    concat!(
                                        "action ", "test_action",
                                        " called with incorrectly typed argument ",
                                        stringify!(choice_data)
                                    ),
                                )?
                        };
                        self.on_test_action(interaction_mode, text_data, choice_data)
                            .await
                            .context(concat!("handle ", "test_action", " action"))?
                    }
                    id => eyre::bail!("action executed with unknown action id {id}"),
                }
            }
            TouchPortalOutput::ConnectorChange(change) => {
                ::tracing::error!(? change, "connector changes are not yet implemented");
            }
            TouchPortalOutput::ShortConnectorIdNotification(assoc) => {
                ::tracing::error!(
                    ? assoc, "short connector id support are not yet implemented"
                );
            }
            TouchPortalOutput::ListChange(change) => {
                #[allow(clippy::match_single_binding)]
                match (&*change.list_id, &*change.action_id) {
                    ("choice_data", "test_action") => {
                        let value: ChoicesForChoiceData = protocol::TouchPortalFromStr::destringify(
                                &change.value,
                            )
                            .with_context(|| {
                                format!(
                                    concat!("list change for choice ", "choice_data",
                                    " called with incorrectly typed select value '{}'"), change
                                    .value
                                )
                            })?;
                        self.on_select_choice_data_in_test_action(
                                change.instance_id,
                                value,
                            )
                            .await
                            .context(concat!("handle ", "choice_data", " list change"))?;
                    }
                    ("choice_data", aid) => {
                        eyre::bail!(
                            "list with known id '{}' changed, but with unexpected action id '{aid}'",
                            change.list_id
                        )
                    }
                    (lid, "test_action") => {
                        eyre::bail!(
                            "unknown list with id '{lid}' changed in known action '{}'",
                            change.action_id
                        )
                    }
                    (lid, aid) => {
                        eyre::bail!(
                            "unknown list '{lid}' in unknown action '{aid}' changed"
                        )
                    }
                }
            }
            TouchPortalOutput::ClosePlugin(_) => {
                self.on_close(false).await.context("handle graceful plugin close")?;
                return Ok(true);
            }
            TouchPortalOutput::Broadcast(event) => {
                self.on_broadcast(event).await.context("handle broadcast event")?;
            }
            TouchPortalOutput::NotificationOptionClicked(event) => {
                self.on_notification_clicked(event)
                    .await
                    .context("handle notification click")?;
            }
            TouchPortalOutput::Settings(settings_msg) => {
                let settings = PluginSettings::from_settings_message(settings_msg)
                    .context("parse settings from message")?;
                self.on_settings_changed(settings)
                    .await
                    .context("handle settings change")?;
            }
            _ => unimplemented!("codegen macro must be updated to handle {msg:?}"),
        }
        Ok(false)
    }
}
